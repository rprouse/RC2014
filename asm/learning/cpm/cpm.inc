; Definitions and methods for CP/M development
;
BDOS        equ $5          ; CP/M BDOS vector address
FCB         equ $5c         ; CP/M default File Control Block (FCB)
BUF         equ $80         ; default dma buffer

CNTRLC      equ $3
;
; define BDOS functions
;
C_READ      equ $01         ; console input
C_WRITE     equ $02         ; console output
C_WRITESTR  equ $09         ; output string, '$' terminated, to console output
C_READSTR   equ $0a         ; buffered console input
C_STAT      equ $0b         ; console status, nonzero if char waiting
DRV_SET     equ $0e         ; select drive
F_OPEN      equ $0f         ; open file
F_CLOSE     equ $10         ; close file
F_READ      equ $14         ; read next file record
F_WRITE     equ $15         ; write record
F_MAKE      equ $16         ; create file
DRV_GET     equ $19         ; get current drive
F_SETDMA    equ $1a         ; set DMA address
DRV_DPB     equ $1f         ; get DPB address
DRV_RESET   equ $25         ; selectively reset a disk drive

str_newline:
    db "\r\n$"
;
;
; general BDOS functions
;
GETC:
    ld c, C_READ
    call BDOS
    ret

PRINT_CHAR:
    push hl
    push de
    push bc

    ld e, a
    ld c, C_WRITE
    call BDOS

    pop bc
    pop de
    pop hl
    ret

PRINT_NEWLINE:
    ;push hl
    ld hl, str_newline
    call PRINT_STR
    ;pop hl
    ret

GET_STR:
    push hl
    push de
    push bc

    ex de, hl
    ld c, C_READSTR
    call BDOS

    pop bc
    pop de
    pop hl
    ret

PRINT_STR:
    push hl
    push de
    push bc

    ex de, hl
    ld c, C_WRITESTR
    call BDOS

    pop bc
    pop de
    pop hl
    ret

; function PRINT_HEX
; print a hexadecimal byte
;
; entry:
;   A byte to print
;
PRINT_HEX:
            PUSH    AF
            RRCA
            RRCA
            RRCA
            RRCA                        ; get high nibble
            CALL    PASS1               ;
            POP     AF
PASS1:      AND     $0F
            ADD     A,$30
            CP      $3A
            JR      C,NUM               ; A < $3a - 0-9
            ADD     A,$07               ; else A-F
NUM:
            CALL    PRINT_CHAR
            RET

; Combined routine for conversion of different sized binary numbers into
; directly printable ASCII(Z)-string
; Input value in registers, number size and -related to that- registers to fill
; is selected by calling the correct entry:
;
;  entry  inputregister(s)  decimal value 0 to:
;   B2D8             A                    255  (3 digits)
;   B2D16           HL                  65535   5   "
;   B2D24         E:HL               16777215   8   "
;   B2D32        DE:HL             4294967295  10   "
;   B2D48     BC:DE:HL        281474976710655  15   "
;   B2D64  IX:BC:DE:HL   18446744073709551615  20   "
;
; The resulting string is placed into a small buffer attached to this routine,
; this buffer needs no initialization and can be modified as desired.
; The number is aligned to the right, and leading 0's are replaced with spaces.
; On exit HL points to the first digit, (B)C = number of decimals
; This way any re-alignment / postprocessing is made easy.
; Changes: AF,BC,DE,HL,IX
; P.S. some examples below

; by Alwin Henseler


B2D8:    LD H,0
         LD L,A
B2D16:   LD E,0
B2D24:   LD D,0
B2D32:   LD BC,0
B2D48:   LD IX,0          ; zero all non-used bits
B2D64:
         LD (B2DINV),HL
         LD (B2DINV+2),DE
         LD (B2DINV+4),BC
         LD (B2DINV+6),IX ; place full 64-bit input value in buffer
         LD HL,B2DBUF
         LD DE,B2DBUF+1
         LD (HL),' '
B2DFILC: EQU $-1            ; address of fill-character
         LD BC,18
         LDIR               ; fill 1st 19 bytes of buffer with spaces
         LD (B2DEND-1),BC ;set BCD value to "0" & place terminating 0
         LD E,1             ; no. of bytes in BCD value
         LD HL,B2DINV+8     ; (address MSB input)+1
         LD BC,0909H
         XOR A
B2DSKP0: DEC B
         JR Z,B2DSIZ        ; all 0: continue with postprocessing
         DEC HL
         OR (HL)            ; find first byte <>0
         JR Z,B2DSKP0
B2DFND1: DEC C
         RLA
         JR NC,B2DFND1      ; determine no. of most significant 1-bit
         RRA
         LD D,A             ; byte from binary input value
B2DLUS2: PUSH HL
         PUSH BC
B2DLUS1: LD HL,B2DEND-1     ; address LSB of BCD value
         LD B,E             ; current length of BCD value in bytes
         RL D               ; highest bit from input value -> carry
B2DLUS0: LD A,(HL)
         ADC A,A
         DAA
         LD (HL),A          ; double 1 BCD byte from intermediate result
         DEC HL
         DJNZ B2DLUS0       ; and go on to double entire BCD value (+carry!)
         JR NC,B2DNXT
         INC E              ; carry at MSB -> BCD value grew 1 byte larger
         LD (HL),1          ; initialize new MSB of BCD value
B2DNXT:  DEC C
         JR NZ,B2DLUS1      ; repeat for remaining bits from 1 input byte
         POP BC             ; no. of remaining bytes in input value
         LD C,8             ; reset bit-counter
         POP HL             ; pointer to byte from input value
         DEC HL
         LD D,(HL)          ; get next group of 8 bits
         DJNZ B2DLUS2       ; and repeat until last byte from input value
B2DSIZ:  LD HL,B2DEND       ; address of terminating 0
         LD C,E             ; size of BCD value in bytes
         OR A
         SBC HL,BC          ; calculate address of MSB BCD
         LD D,H
         LD E,L
         SBC HL,BC
         EX DE,HL           ; HL=address BCD value, DE=start of decimal value
         LD B,C             ; no. of bytes BCD
         SLA C              ; no. of bytes decimal (possibly 1 too high)
         LD A,'0'
         RLD                ; shift bits 4-7 of (HL) into bit 0-3 of A
         CP '0'             ; (HL) was > 9h?
         JR NZ,B2DEXPH      ; if yes, start with recording high digit
         DEC C              ; correct number of decimals
         INC DE             ; correct start address
         JR B2DEXPL         ; continue with converting low digit
B2DEXP:  RLD                ; shift high digit (HL) into low digit of A
B2DEXPH: LD (DE),A          ; record resulting ASCII-code
         INC DE
B2DEXPL: RLD
         LD (DE),A
         INC DE
         INC HL             ; next BCD-byte
         DJNZ B2DEXP        ; and go on to convert each BCD-byte into 2 ASCII
         SBC HL,BC          ; return with HL pointing to 1st decimal
         RET

B2DINV:  DS 8               ; space for 64-bit input value (LSB first)
B2DBUF:  DS 20              ; space for 20 decimal digits
B2DEND:  DS 2, '$';S 1      ; space for terminating 0
